<html>
  <head>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="w-full">
    <div style="font-family: sans-serif; padding: 1em">
      <h1 class="text-lg font-bold text-emerald-500 mb-4">Kanban</h1>

      <div
        class="flex justify-start items-center gap-6 p-4 mb-3 bg-slate-50 dark:bg-slate-500, rounded"
      >
        <select
          name="sortby"
          id="sortBy"
          class="rounded-lg p-3 text-sm shadow-md"
        >
          <option class="text-sm" value="none" selected>
            Choisissez une source
          </option>
        </select>

        <button
          id="visBtn"
          class="text-sm p-3 border-none bg-white rounded dark:bg-slate-500 shadow-md hover:bg-emerald-500 hover:text-white"
        >
          Afficher les colonnes
        </button>

        <button
          id="fieldsBtn"
          class="text-sm p-3 border-none bg-white rounded dark:bg-slate-500 shadow-md hover:bg-emerald-500 hover:text-white"
        >
          Afficher les champs
        </button>
      </div>
      <div class="flex w-full gap-4 items-start">
        <div
          id="visPanel"
          class="p-2 w-full bg-white rounded mb-3 hidden"
        ></div>
        <div
          id="fieldsPanel"
          class="p-2 w-full bg-white rounded mb-3 hidden"
        ></div>
      </div>

      <div
        id="wrapper"
        class="text-xs w-full items-stretch justify-between flex gap-2"
      ></div>
    </div>
    <script>
      grist.ready({ requiredAccess: "full", allowSelectBy: true });

      // Déclaration des variables
      const select = document.getElementById("sortBy");
      const wrapper = document.getElementById("wrapper");
      const visBtn = document.getElementById("visBtn");
      const visPanel = document.getElementById("visPanel");
      const fieldsBtn = document.getElementById("fieldsBtn");
      const fieldsPanel = document.getElementById("fieldsPanel");
      const empty = "(vide)";

      // État global
      let allColsMeta = [];
      let lastRecords = [];
      let choices = [];
      let currentTableId = null;
      let widgetOptions = {};
      let choicesInitialized = false;

      // Utils
      function strNoAccent(str) {
        return (str ?? "")
          .toString()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "");
      }

      function norm(s) {
        return (s ?? "")
          .toString()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase();
      }

      function safeParse(json) {
        try {
          return json ? JSON.parse(json) : null;
        } catch {
          return null;
        }
      }

      function isEmptyValue(v) {
        if (Array.isArray(v)) return v.length === 0;
        return v === null || v === undefined || v === "";
      }

      function sourceKey(source) {
        return "kanban:source"; // 1 seule source mémorisée par vue
      }

      function hiddenKey(colId) {
        return `kanban:hidden:${colId}`;
      }

      function hiddenFieldsKey(tableId, sourceColId) {
        return `kanban:hiddenFields:${tableId}:${sourceColId}`;
      }

      function getColMetaById(colId) {
        return allColsMeta.find((c) => (c.colId || c.id) === colId) || null;
      }

      function parseWidgetOptions(meta) {
        try {
          return meta?.widgetOptions ? JSON.parse(meta.widgetOptions) : null;
        } catch {
          return null;
        }
      }
      function getFieldType(meta) {
        if (!meta) return "Unknown";
        const raw = String(meta.type || "").toLowerCase();
        const wo = parseWidgetOptions(meta);

        // Widget explicite
        const w = (wo?.widget || "").toLowerCase();
        if (w === "choice") return "Choice";
        if (w === "choicelist") return "ChoiceList";

        // Type brut Grist
        if (raw.startsWith("reflist")) return "RefList";
        if (raw.startsWith("ref")) return "Ref";

        if (raw.includes("choice"))
          return raw.includes("list") ? "ChoiceList" : "Choice";
        if (raw.includes("date") && raw.includes("time")) return "DateTime";
        if (raw.includes("date")) return "Date";
        if (raw.includes("bool")) return "Bool";
        if (raw.includes("attach")) return "Attachments";
        if (raw.includes("num") || raw.includes("int") || raw.includes("float"))
          return "Number";
        if (raw.includes("text") || raw === "") return "Text";

        // fallback
        return meta.type || "Text";
      }

      // Essaie d'identifier le type "visuel" appliqué à la colonne (percent, currency, etc.)
      function getDisplayStyle(meta) {
        const wo = parseWidgetOptions(meta) || {};
        console.log("WidgetOptions", wo);
        const rawType = String(meta?.type || "").toLowerCase();

        // Récupération de champs candidats fréquents
        const widget = (wo.widget || "").toLowerCase();
        const numMode = (wo.numMode || "").toLowerCase();
        const numFormat = wo.numFormat || wo.format || "";
        const decimals = wo.decimals ?? wo.precision ?? wo.fracDigits ?? null;
        const currency = wo.currency || wo.currencyCode || wo.symbol || null;
        const unit = wo.unit || wo.suffix || null;

        const dateFormat = wo.dateFormat || null;
        const timeFormat = wo.timeFormat || null;
        const align = wo.align || wo.alignment || null;

        //Number
        const isNumberLike =
          rawType.includes("num") ||
          rawType.includes("number") ||
          rawType.includes("int") ||
          rawType.includes("float") ||
          rawType === "numeric";

        //Percent
        const looksPercent =
          numMode === "percent" ||
          widget === "percent" ||
          /%/.test(String(numFormat)) ||
          unit === "%" ||
          (isNumberLike && wo.percent === true);

        //Currency
        const looksCurrency =
          numMode === "currency" ||
          widget === "currency" ||
          currency != null ||
          /[$€£¥]/.test(String(numFormat));

        //Date
        const isDateTime = rawType.includes("datetime");
        const isDate = rawType.includes("date") && !isDateTime;
        const isTime = rawType.includes("time") && !isDateTime;

        // Construction d'un objet
        if (isNumberLike) {
          if (looksPercent) {
            return {
              kind: "percent",
              decimals: decimals ?? 0,
              format: numFormat || null,
              unit: unit || "%",
              align: align || "right",
            };
          }
          if (looksCurrency) {
            return {
              kind: "currency",
              currency: currency || guessCurrencyFromFormat(numFormat) || "EUR",
              decimals: decimals ?? 2,
              format: numFormat || null,
              align: align || "right",
            };
          }
          return {
            kind: "number",
            decimals: decimals ?? guessDecimalsFromFormat(numFormat),
            format: numFormat || null,
            align: align || "right",
            unit: unit || null,
          };
        }

        if (isDateTime) {
          return {
            kind: "datetime",
            dateFormat: dateFormat || guessDateFormat(dateFormat),
            timeFormat: timeFormat || guessTimeFormat(timeFormat),
            align: align || "left",
          };
        }
        if (isDate) {
          return {
            kind: "date",
            dateFormat: dateFormat || guessDateFormat(dateFormat),
            align: align || "left",
          };
        }
        if (isTime) {
          return {
            kind: "time",
            timeFormat: timeFormat || guessTimeFormat(numFormat),
            align: align || "left",
          };
        }

        // Choice / ChoiceList / Ref / Text / Attachments...
        return {
          kind: "default",
          align: align || (rawType.includes("text") ? "left" : "left"),
        };
      }

      // Helpers
      function guessCurrencyFromFormat(fmt) {
        if (!fmt) return null;
        if (fmt.includes("€")) return "EUR";
        if (fmt.includes("$")) return "USD";
        if (fmt.includes("£")) return "GBP";
        if (fmt.includes("¥")) return "JPY";
        return null;
      }
      function guessDecimalsFromFormat(fmt) {
        if (!fmt) return null;
        const m = fmt.match(/\.0+/);
        return m ? m[0].length - 1 : null;
      }
      function guessDateFormat(fmt) {
        if (!fmt) return null;
        // Heuristique simple sur tokens classiques
        if (/YYYY.*MM.*DD/i.test(fmt)) return "YYYY-MM-DD";
        if (/DD.*MM.*YYYY/i.test(fmt)) return "DD/MM/YYYY";
        if (/MM.*DD.*YYYY/i.test(fmt)) return "MM/DD/YYYY";
        return null;
      }
      function guessTimeFormat(fmt) {
        if (!fmt) return null;
        if (/HH.*mm.*ss/i.test(fmt)) return "HH:mm:ss";
        if (/HH.*mm/i.test(fmt)) return "HH:mm";
        if (/hh.*mm.*a/i.test(fmt)) return "hh:mm a";
        return null;
      }

      const DOC_ENV = (() => {
        const p = new URLSearchParams(location.search);
        const tz =
          Intl.DateTimeFormat().resolvedOptions().timeZone || "Europe/Paris";
        return {
          culture: p.get("culture") || navigator.language || "fr-FR",
          currency: p.get("currency") || "EUR",
          timeZone: p.get("timeZone")
            ? decodeURIComponent(p.get("timeZone"))
            : tz,
          language: p.get("language") || navigator.language || "fr-FR",
        };
      })();

      // Getter et Setter pour les options persistées

      function getStoredSource(source) {
        const v = widgetOptions?.[sourceKey()] || "";
        return v;
      }

      function getHiddenFor(colId) {
        const v = widgetOptions?.[hiddenKey(colId)];
        return Array.isArray(v) ? v : []; // on retourne toujours un tableau
      }

      function getHiddenFields(tableId, sourceColId) {
        const v = widgetOptions?.[hiddenFieldsKey(tableId, sourceColId)];
        return Array.isArray(v) ? v : [];
      }
      async function setHiddenFields(tableId, sourceColId, arr) {
        widgetOptions[hiddenFieldsKey(tableId, sourceColId)] = arr;
        await grist.widgetApi.setOption(
          hiddenFieldsKey(tableId, sourceColId),
          arr
        );
      }

      async function initChoicesOnce() {
        if (choicesInitialized) return;
        const cols = await getAllColumns();

        allColsMeta = cols;
        while (select.options.length > 1) select.remove(1);
        choices = [];

        for (const col of cols) {
          if (isChoiceLike(col)) {
            const opt = document.createElement("option");
            opt.value = col.colId || col.id || "";
            opt.textContent = col.label || col.colId || "(?)";
            select.appendChild(opt);
            choices.push(col);
          }
        }
        // Restaure la source mémorisée (si valide)
        const stored = getStoredSource();
        if (stored) {
          // si l'option existe encore dans la liste, on la sélectionne
          const has = Array.from(select.options).some(
            (o) => o.value === stored
          );
          if (has) {
            select.value = stored;
          }
        }

        // Si rien n’est sélectionné (ou stored invalide), on prend la 1ère option valide
        if (select.value === "none" && select.options.length > 1) {
          select.value = select.options[1].value;
          await setStoredSource(select.value);
        }

        choicesInitialized = true;
        // debugDumpColumnFormats();
      }

      async function setStoredSource(source) {
        await grist.widgetApi.setOption(sourceKey(), source); // persiste dans le doc
      }

      async function setHiddenFor(colId, arr) {
        widgetOptions[hiddenKey(colId)] = arr; // met à jour le cache local
        await grist.widgetApi.setOption(hiddenKey(colId), arr);
      }

      // Initialisation de l'ID de la table actuelle
      async function initCurrentTableId() {
        if (currentTableId) return currentTableId;
        const table = await grist.getTable();
        currentTableId = await table._platform.getTableId();
        return currentTableId;
      }

      // Récupère les options persistées
      grist.onOptions((opts) => {
        widgetOptions = opts || {};
      });

      // Fonction pour récupérer toutes les colonnes de la table actuelle
      async function getAllColumns() {
        const table = await grist.getTable();
        const tableId = await table._platform.getTableId();
        const tables = await grist.docApi.fetchTable("_grist_Tables");
        const columns = await grist.docApi.fetchTable("_grist_Tables_column");
        const fields = Object.keys(columns);

        const tableColumns = [];
        if (!tableId) {
          console.log("Aucun id de table trouvé");
          return tableColumns;
        }
        const tableRef = tables.id[tables.tableId.indexOf(tableId)];
        for (const index in columns.parentId) {
          if (columns.parentId[index] === tableRef) {
            tableColumns.push(
              Object.fromEntries(fields.map((f) => [f, columns[f][index]]))
            );
          }
        }
        return tableColumns;
      }
      function debugDumpColumnFormats() {
        console.group("GRIST Column Formats");
        for (const c of allColsMeta) {
          const colId = c.colId || c.id;
          const t = getFieldType(c);
          const style = getDisplayStyle(c);
          console.log({
            displayStyle: style,
          });
        }
        console.groupEnd();
      }

      // Fonction pour reconstruire la liste des en-têtes visibles en fonction des colonnes masquées

      function buildVisibleHeaders(colMeta, allHeaders) {
        const colId = colMeta.colId || colMeta.id;
        const hidden = new Set(getHiddenFor(colId).map(norm));
        return allHeaders.filter((h) => !hidden.has(norm(h.value)));
      }
      /* ---------------------------------------------
               Helpers pour reconnaître Choice/ChoiceList
               et extraire l'ordre des 'choices' depuis widgetOptions
               --------------------------------------------- */
      function isChoiceLike(colMeta) {
        const wo = safeParse(colMeta?.widgetOptions);
        // Certaines versions stockent le widget +/ou les choices
        return (
          wo?.widget === "Choice" ||
          wo?.widget === "ChoiceList" ||
          !!wo?.choices ||
          !!wo?.choicesById
        );
      }
      function getChoicesFromMeta(colMeta) {
        const wo = safeParse(colMeta?.widgetOptions);
        if (!wo) return [];

        let result = [];

        // 1) Si wo.choices est un tableau
        if (wo && Array.isArray(wo.choices)) {
          for (const c of wo.choices) {
            let label;
            if (typeof c === "string") {
              label = c;
            } else if (c && (c.label != null || c.value != null)) {
              label = c.label != null ? c.label : c.value;
            } else {
              label = "";
            }
            if (label) result.push(label);
          }
          return result;
        }

        // 2) Sinon, si wo.choicesById est un objet
        if (wo && typeof wo.choicesById === "object") {
          for (const key of Object.keys(wo.choicesById)) {
            const c = wo.choicesById[key];
            const label = (c && (c.label ?? c.value)) || "";
            if (label) result.push(label);
          }
          return result;
        }

        // 3) Sinon, rien
        return result;
      }

      // Initialisation du menu déroulant avec les colonnes de type "Choice"

      (async () => {
        try {
          const cols = await getAllColumns();
          allColsMeta = cols;

          for (const col of cols) {
            if (isChoiceLike(col)) {
              const option = document.createElement("option");
              option.classList.add(
                "text-sm",

                "select-none",
                "focus:bg-emerald-500",
                "focus:text-white"
              );

              option.value = col.colId || col.id || "";
              option.textContent = col.label || col.colId || "(?)";
              select.appendChild(option);

              choices.push(col);
            }
          }
        } catch (e) {
          console.error(e);
        }
      })();

      // Marque une carte comme "draggable" et envoie les infos utiles lors du drag
      function makeCardDraggable(cardEl, rowId, fromHeaderValue, sourceColId) {
        cardEl.draggable = true; // indispensable pour activer le drag natif
        cardEl.addEventListener("dragstart", (e) => {
          // On stocke dans le dataTransfer les infos utiles pour l'update au drop
          e.dataTransfer.setData("rowId", String(rowId));
          e.dataTransfer.setData("fromHeader", fromHeaderValue); // valeur d'origine (ex: "À faire")
          e.dataTransfer.setData("sourceColId", sourceColId); // nom du champ (ex: "Statut")
          e.dataTransfer.effectAllowed = "move";
        });
      }

      // Fonction pour rendre les en-têtes basés sur les valeurs uniques de la colonne sélectionnée
      function renderHeader(source, records) {
        const order = getChoicesFromMeta(source);
        wrapper.innerHTML = "";
        const headers = order.map((value, index) => ({ index, value }));
        headers.unshift({ index: 0, value: empty });
        return headers;
      }

      function formatValueForDisplay(value, style) {
        if (value == null || value === "") return "";

        // Numbers + variations
        if (style?.kind === "percent") {
          const decimals = style.decimals ?? 0;
          // si valeur <= 1 et >= -1, traite comme ratio → x100
          const n =
            Math.abs(Number(value)) <= 1 ? Number(value) * 100 : Number(value);
          return `${n.toLocaleString(DOC_ENV.culture, {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals,
          })} %`;
        }

        if (style?.kind === "currency") {
          const decimals = style.decimals ?? 2;
          const ccy = style.currency || DOC_ENV.currency || "EUR";
          return Number(value).toLocaleString(DOC_ENV.culture, {
            style: "currency",
            currency: ccy,
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals,
          });
        }

        if (style?.kind === "number") {
          const decimals = style.decimals ?? 0;
          return Number(value).toLocaleString(DOC_ENV.culture, {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals,
          });
        }

        return String(value);
      }

      function renderBool(value) {
        const wrap = document.createElement("span");
        wrap.className = "inline-flex items-center gap-1";
        const icon = document.createElement("span");
        icon.className =
          "inline-flex items-center justify-center w-4 h-4 rounded border";
        if (value === true) {
          icon.classList.add(
            "bg-emerald-500",
            "border-emerald-500",
            "text-white"
          );
          icon.textContent = "✓";
        } else if (value === false) {
          icon.classList.add(
            "bg-transparent",
            "border-slate-300",
            "text-slate-400"
          );
          icon.textContent = "✕";
        } else {
          // null / vide
          icon.classList.add(
            "bg-transparent",
            "border-slate-300",
            "text-slate-300"
          );
          icon.textContent = "–";
        }
        wrap.appendChild(icon);
        return wrap;
      }

      function renderChoice(meta, raw) {
        const span = document.createElement("span");
        span.className = "inline-flex items-center gap-1";
        const dot = document.createElement("span");
        dot.className = "inline-block w-2 h-2 rounded-full";

        span.appendChild(dot);
        span.appendChild(document.createTextNode(String(raw ?? "")));
        return span;
      }

      function renderChoiceList(meta, arr) {
        const frag = document.createDocumentFragment();
        (arr || []).forEach((val) => {
          const chip = document.createElement("span");
          chip.className =
            "inline-block text-[10px] px-2 py-0.5 mr-1 mb-1 rounded";

          chip.style.color = "#111827";
          chip.textContent = val;
          frag.appendChild(chip);
        });
        return frag;
      }

      function renderRef(raw) {
        // Par défaut on affiche l’ID (#123). Pour afficher le libellé de la table référencée,
        // il faudrait une jointure via docApi (possible mais plus long).
        const span = document.createElement("span");
        span.textContent = raw == null ? "" : `#${raw}`;
        return span;
      }

      /**
       * Retourne un élément DOM formaté selon le type.
       * - Utilise ton formatValueForDisplay pour Number/Currency/Percent.
       * - Aligne à droite les numériques.
       */
      function renderFieldValue(meta, fieldType, style, raw) {
        // Bool -> coche
        if (fieldType === "Bool") {
          return renderBool(raw);
        }

        // ChoiceList -> chips colorées
        if (fieldType === "ChoiceList" && Array.isArray(raw)) {
          return renderChoiceList(meta, raw);
        }

        // Choice -> pastille + libellé
        if (fieldType === "Choice" && typeof raw === "string") {
          return renderChoice(meta, raw);
        }

        // Ref / RefList (simple: affiche IDs)
        if (fieldType === "Ref") {
          return renderRef(raw);
        }
        if (fieldType === "RefList" && Array.isArray(raw)) {
          const span = document.createElement("span");
          span.textContent = raw.map((r) => `#${r}`).join(", ");
          return span;
        }

        // Number / Currency / Percent -> texte formaté + alignement
        if (
          style?.kind === "number" ||
          style?.kind === "currency" ||
          style?.kind === "percent"
        ) {
          const p = document.createElement("p");
          p.textContent = formatValueForDisplay(raw, style);
          if (style?.align === "right")
            p.classList.add("text-right", "self-stretch");
          return p;
        }

        // Date/DateTime/Time : laisse tel quel (ou ajoute un parse/format ici si tes valeurs sont ISO)
        // Par défaut: texte
        const p = document.createElement("p");
        p.textContent = raw == null ? "" : String(raw);
        return p;
      }

      // Fonction pour afficher le panneau de gestion de la visibilité des colonnes
      function renderVisibilityUI(colMeta) {
        const colId = colMeta.colId || colMeta.id;
        const all = [empty, ...getChoicesFromMeta(colMeta)]; // toutes les colonnes possibles
        const hidden = new Set(getHiddenFor(colId).map(norm));

        visPanel.innerHTML =
          "<div class='font-medium mb-2 text-sm font-bold'>Colonnes :</div>";
        const list = document.createElement("div");
        list.className = "grid grid-cols-2 gap-1 text-sm";
        visPanel.appendChild(list);

        for (const label of all) {
          const row = document.createElement("label");
          row.className = "flex items-center gap-2  text-sm";
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = !hidden.has(norm(label)); // coché = visible
          cb.addEventListener("change", async () => {
            const cur = new Set(getHiddenFor(colId).map(norm));
            const key = norm(label);
            if (cb.checked) cur.delete(key);
            else cur.add(key);
            await setHiddenFor(colId, Array.from(cur));
            rerenderKanban(colMeta, lastRecords, colId); // réaffiche/récache immédiatement
            renderVisibilityUI(colMeta); // refresh le panneau
          });
          const span = document.createElement("span");
          span.textContent = label;
          row.appendChild(cb);
          row.appendChild(span);
          list.appendChild(row);
        }
      }

      const visClass = visPanel.classList;
      visBtn.addEventListener("click", () => {
        const isHidden = visClass.toggle("hidden");
        visBtn.textContent = `${
          isHidden ? "Afficher les colonnes" : "Masquer les colonnes"
        }`;
      });

      // Panneau de gestion des champs affichés dans les cartes
      function renderFieldsUI(colMeta) {
        // colMeta = meta de la SOURCE (Choice)
        const tableCols = allColsMeta;
        const sourceColId = colMeta.colId || colMeta.id;

        // récupère l’ID de table courant que tu as déjà en global (currentTableId)
        const tableId = currentTableId;
        if (!tableId) return;

        // liste des champs affichables dans les cards
        const fieldMetas = tableCols.filter((c) => {
          const cid = c.colId || c.id || "";
          if (!cid) return false;
          if (cid === "id") return false;
          if (cid === "manualSort") return false; //
          if (cid === sourceColId) return false; // on n’affiche pas la colonne Choice dans la carte
          return true;
        });

        // set des champs masqués (normalisés)

        fieldsPanel.innerHTML =
          "<div class='font-medium mb-2  text-sm'>Champs :</div>";
        const list = document.createElement("div");
        list.className = "grid grid-cols-2 gap-1  text-sm";
        fieldsPanel.appendChild(list);

        const hiddenArr = getHiddenFields(tableId, sourceColId);
        const hidden = new Set(hiddenArr.map(norm));
        const isDefaultMode = hiddenArr.length === 0;
        const allCids = fieldMetas.map((f) => f.colId || f.id);

        const defaultVisible = fieldMetas
          .map((f) => f.colId || f.id)
          .slice(0, 3);

        for (const fm of fieldMetas) {
          if ((fm.colId || fm.id) === "manualSort") continue;
          const cid = fm.colId || fm.id;
          const label = fm.label || cid;
          const row = document.createElement("label");
          row.className = "flex items-center gap-2 text-sm";

          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = isDefaultMode
            ? defaultVisible.includes(cid)
            : !hidden.has(norm(cid));

          cb.addEventListener("change", async () => {
            const hiddenNow = getHiddenFields(tableId, sourceColId).map(norm);
            const isDefaultNow = hiddenNow.length === 0;

            let visibleSet;
            if (isDefaultNow) {
              visibleSet = new Set(defaultVisible);
            } else {
              const hiddenNowSet = new Set(hiddenNow);
              visibleSet = new Set(
                allCids.filter((c) => !hiddenNowSet.has(norm(c)))
              );
            }

            // appliquer l'action utilisateur
            if (cb.checked) {
              visibleSet.add(cid);
            } else {
              visibleSet.delete(cid);
            }

            // nouveaux masqués = complément
            const newHidden = allCids.filter((c) => !visibleSet.has(c));

            await setHiddenFields(tableId, sourceColId, newHidden);

            // re-render immédiat
            const selectedColumn = catchColumn(choices, sourceColId);
            if (selectedColumn) {
              rerenderKanban(selectedColumn, lastRecords, sourceColId);
              renderFieldsUI(selectedColumn);
            }
          });

          const span = document.createElement("span");
          span.textContent = label;

          row.appendChild(cb);
          row.appendChild(span);
          list.appendChild(row);
        }
      }

      const fieldsClass = fieldsPanel.classList;
      fieldsBtn.addEventListener("click", () => {
        const isHidden = fieldsClass.toggle("hidden");
        fieldsBtn.textContent = `${
          isHidden ? "Afficher les champs" : "Masquer les champs"
        }`;
      });

      // Fonction pour créer les éléments d'en-tête dans le DOM
      function createKanban(leadHeader, wrapper, records, source) {
        const sourceColId = source;
        wrapper.innerHTML = "";

        const tableId = currentTableId;

        const hiddenFields = getHiddenFields(tableId, source);
        const hiddenFieldSet = new Set(hiddenFields.map(norm));
        const isDefault = hiddenFields.length === 0;

        for (const item of leadHeader) {
          const column = document.createElement("div");
          column.classList.add(
            "w-full",
            "flex",
            "flex-col",
            "gap-4",
            "items-center",
            "bg-slate-50",
            "rounded"
          );
          wrapper.appendChild(column);

          const head = document.createElement("h2");
          head.textContent = item.value;
          head.classList.add(
            "w-full",
            "p-4",
            "text-center",
            "font-semibold",
            "bg-emerald-500",
            "text-white",
            "rounded-t",
            "sticky",
            "top-0"
          );
          column.prepend(head);

          const hiddenSet = new Set(getHiddenFor(source).map(norm));
          const labelKey = norm(item.value);

          if (hiddenSet.has(labelKey)) {
            column.style.display = "none";
          }

          enableColumnDrop(column, item.value, source);

          for (const record of records) {
            const cellValue = record[source];
            const headerValue = item.value;

            let isMatch = false;

            if (headerValue === empty) {
              isMatch = isEmptyValue(cellValue);
            } else if (Array.isArray(cellValue)) {
              // ChoiceList : on vérifie si au moins une valeur de la liste correspond
              isMatch = cellValue.some(
                (v) => strNoAccent(v) === strNoAccent(headerValue)
              );
            } else {
              // Choice (scalaire)
              isMatch = strNoAccent(cellValue) === strNoAccent(headerValue);
            }

            if (!isMatch) continue;

            const card = document.createElement("div");
            card.classList.add(
              "card",
              "w-5/6",
              "rounded-lg",
              "shadow-lg",
              "p-3",
              "h-auto",
              "cursor-pointer",
              "bg-white",
              "hover:bg-emerald-50",
              "dark:bg-gray-500",
              "dark:hover:bg-gray-700"
            );

            let keys = Object.keys(record).filter(
              (k) =>
                k !== "id" &&
                k !== source &&
                k !== "manualSort" &&
                !hiddenFieldSet.has(norm(k))
            );

            if (isDefault) {
              keys = keys.slice(0, 3);
            }
            const fieldsTypes = [];
            for (const infos of keys) {
              const meta = getColMetaById(infos);
              const fieldType = getFieldType(meta);
              const style = getDisplayStyle(meta);
              const row = document.createElement("div");
              row.classList.add(
                "flex",
                "flex-col",
                "gap-2",
                "items-start",
                "p-2"
              );
              const titleItem = document.createElement("p");
              titleItem.innerHTML = `${infos}&nbsp;:`;
              titleItem.classList.add("font-semibold");
              // const contentItem = document.createElement("p");

              const raw = record[infos];
              const contentEl = renderFieldValue(meta, fieldType, style, raw);

              row.appendChild(titleItem);
              row.appendChild(contentEl);
              card.appendChild(row);
            }
            column.appendChild(card);
            card.dataset.rowId = record.id;

            card.addEventListener("click", () => {
              if (record.id !== undefined) {
                grist.setCursorPos({ rowId: record.id }); // Position l'éditeur de Grist sur le bon record
              }
            });

            makeCardDraggable(card, record.id, item.value, source);
          }
        }
      }
      function rerenderKanban(selectedColumn, records, colId) {
        // 1) Construire TOUS les headers
        const allHeaders = renderHeader(selectedColumn, records); // ex. renvoie [{index, value}, …]

        // 2) Filtrer selon l’option "hidden" persistée
        const visibleHeaders = buildVisibleHeaders(selectedColumn, allHeaders);

        // 3) Dessiner uniquement les colonnes visibles
        createKanban(visibleHeaders, wrapper, records, colId);
      }

      function catchColumn(choices, selectedSource) {
        for (const col of choices) {
          if ((col.colId || col.id) === selectedSource) {
            return col; // on renvoie l'objet méta complet (accès à widgetOptions)
          }
        }
        return null;
      }

      // Met à jour la cellule (Choice ou ChoiceList) après un drop
      async function updateCardAfterDrop(
        rowId,
        sourceColId,
        fromHeaderValue,
        toHeaderValue,
        currentCellValue
      ) {
        await initCurrentTableId();
        // Normalise pour comparer sans accents
        const eq = (a, b) => strNoAccent(a) === strNoAccent(b);

        let newValue;
        if (toHeaderValue === empty) {
          newValue = Array.isArray(currentCellValue) ? [] : null;
        } else if (Array.isArray(currentCellValue)) {
          // CHOICELIST : on retire l'ancienne valeur (si présente) et on ajoute la nouvelle
          const withoutOld = currentCellValue.filter(
            (v) => !eq(v, fromHeaderValue)
          );
          // Évite doublon
          if (!withoutOld.some((v) => eq(v, toHeaderValue))) {
            withoutOld.push(toHeaderValue);
          }
          newValue = withoutOld;
        } else {
          // CHOICE (scalaire) : on remplace simplement par la nouvelle valeur
          newValue = toHeaderValue;
        }

        // Update côté Grist
        const action = [
          "UpdateRecord",
          currentTableId,
          rowId,
          { [sourceColId]: newValue },
        ];
        await grist.docApi.applyUserActions([action]);
      }

      // Active le drop sur une colonne Kanban donnée
      function enableColumnDrop(columnEl, headerValue, sourceColId) {
        // Autorise le dépôt
        columnEl.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          columnEl.classList.add("ring-2", "ring-emerald-500");
        });

        columnEl.addEventListener("dragleave", () => {
          columnEl.classList.remove("ring-2", "ring-emerald-500");
        });

        // Récupère les infos envoyées par la carte au dragstart et update
        columnEl.addEventListener("drop", async (e) => {
          e.preventDefault();
          columnEl.classList.remove("ring-2", "ring-emerald-500");
          const rowId = Number(e.dataTransfer.getData("rowId"));
          const fromHeader = e.dataTransfer.getData("fromHeader"); // d'où venait la carte
          const sourceCol = e.dataTransfer.getData("sourceColId"); // sécurité (doit = sourceColId)

          if (!rowId || !sourceCol) return;
          if (sourceCol !== sourceColId) return;

          // On a besoin de la valeur actuelle pour savoir si c'est ChoiceList
          const record = lastRecords.find((r) => r.id === rowId);
          if (!record) return;
          const currentCellValue = record[sourceColId];

          // headerValue = valeur de la colonne où on droppe
          await updateCardAfterDrop(
            rowId,
            sourceColId,
            fromHeader,
            headerValue,
            currentCellValue
          );
        });
      }

      // Écouteur d'événements pour le changement de sélection dans le menu déroulant
      select.addEventListener("change", async () => {
        const selectedSource = select.value;
        await setStoredSource(selectedSource);

        const selectedColumn = catchColumn(choices, selectedSource);
        if (!selectedColumn) return;
        renderVisibilityUI(selectedColumn);
        renderFieldsUI(selectedColumn);
        rerenderKanban(selectedColumn, lastRecords, selectedSource);
      });

      // Écouteurs d'événements Grist
      grist.onRecords(async (records) => {
        lastRecords = records || [];

        await initCurrentTableId();
        await initChoicesOnce();

        if (select.value === "none") {
          const stored = getStoredSource();
          if (stored) {
            const has = Array.from(select.options).some(
              (o) => o.value === stored
            );
            if (has) select.value = stored;
          }
        }
        const selectedSource = select.value;
        const selectedColumn = catchColumn(choices, selectedSource);
        if (!selectedColumn) return;
        renderVisibilityUI(selectedColumn);
        renderFieldsUI(selectedColumn);
        rerenderKanban(selectedColumn, lastRecords, selectedSource);
      });

      grist.onRecord((record) => {});
    </script>
  </body>
</html>
