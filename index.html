<html>
  <head>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body>
    <div style="font-family: sans-serif; padding: 1em">
      <h1 class="text-2xl/7 font-bold text-gray-900 dark:text-white mb-4">
        Vue Kanban
      </h1>

      <select name="sortby" id="sortBy">
        <option value="none">Choisissez une source</option>
      </select>
      <button id="visBtn" class="px-2 py-1 border rounded mb-2">
        Choisir les colonnes
      </button>
      <div id="visPanel" class="p-2 border rounded mb-3 hidden"></div>
      <button id="fieldsBtn" class="px-2 py-1 border rounded mb-2">
        Choisir les champs
      </button>
      <div id="fieldsPanel" class="p-2 border rounded mb-3 hidden"></div>
      <div
        id="wrapper"
        class="text-xs mx-full max-w-7xl items-start justify-between h-full flex divide-x-2 divide-slate-200"
      ></div>
    </div>
    <script>
      grist.ready({ requiredAccess: "full", allowSelectBy: true });

      // Déclaration des variables
      const select = document.getElementById("sortBy");
      const wrapper = document.getElementById("wrapper");
      const visBtn = document.getElementById("visBtn");
      const visPanel = document.getElementById("visPanel");
      const fieldsBtn = document.getElementById("fieldsBtn");
      const fieldsPanel = document.getElementById("fieldsPanel");
      const empty = "(vide)";

      // État global
      let allColsMeta = [];
      let lastRecords = [];
      let choices = [];
      let currentTableId = null;
      let widgetOptions = {};
      let choicesInitialized = false;

      // Utils
      function strNoAccent(str) {
        return (str ?? "")
          .toString()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "");
      }

      function norm(s) {
        return (s ?? "")
          .toString()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase();
      }

      function safeParse(json) {
        try {
          return json ? JSON.parse(json) : null;
        } catch {
          return null;
        }
      }

      function isEmptyValue(v) {
        if (Array.isArray(v)) return v.length === 0;
        return v === null || v === undefined || v === "";
      }

      function sourceKey(source) {
        return "kanban:source"; // 1 seule source mémorisée par vue
      }

      function hiddenKey(colId) {
        return `kanban:hidden:${colId}`;
      }

      function hiddenFieldsKey(tableId, sourceColId) {
        return `kanban:hiddenFields:${tableId}:${sourceColId}`;
      }

      // Getter et Setter pour les options persistées

      function getStoredSource(source) {
        const v = widgetOptions?.[sourceKey()] || "";
        return v;
      }

      function getHiddenFor(colId) {
        const v = widgetOptions?.[hiddenKey(colId)];
        return Array.isArray(v) ? v : []; // on retourne toujours un tableau
      }

      function getHiddenFields(tableId, sourceColId) {
        const v = widgetOptions?.[hiddenFieldsKey(tableId, sourceColId)];
        return Array.isArray(v) ? v : [];
      }
      async function setHiddenFields(tableId, sourceColId, arr) {
        widgetOptions[hiddenFieldsKey(tableId, sourceColId)] = arr;
        await grist.widgetApi.setOption(
          hiddenFieldsKey(tableId, sourceColId),
          arr
        );
      }

      async function initChoicesOnce() {
        if (choicesInitialized) return;
        // on est sûrs d'être *après* la liaison (onRecords vient d'arriver)
        const cols = await getAllColumns();
        allColsMeta = cols;

        // vide d'abord le select
        while (select.options.length > 1) select.remove(1);
        choices = [];

        for (const col of cols) {
          if (isChoiceLike(col)) {
            const opt = document.createElement("option");
            opt.value = col.colId || col.id || "";
            opt.textContent = col.label || col.colId || "(?)";
            select.appendChild(opt);
            choices.push(col);
          }
        }
        // Restaure la source mémorisée (si valide)
        const stored = getStoredSource();
        if (stored) {
          // si l'option existe encore dans la liste, on la sélectionne
          const has = Array.from(select.options).some(
            (o) => o.value === stored
          );
          if (has) {
            select.value = stored;
          }
        }

        // Si rien n’est sélectionné (ou stored invalide), on prend la 1ère option valide
        if (select.value === "none" && select.options.length > 1) {
          select.value = select.options[1].value;
          await setStoredSource(select.value);
        }

        choicesInitialized = true;
      }

      async function setStoredSource(source) {
        await grist.widgetApi.setOption(sourceKey(), source); // persiste dans le doc
        // après setOption, onOptions sera rappelé automatiquement avec les valeurs à jour
      }

      async function setHiddenFor(colId, arr) {
        widgetOptions[hiddenKey(colId)] = arr; // met à jour le cache local
        await grist.widgetApi.setOption(hiddenKey(colId), arr); // persiste dans le doc
        // après setOption, onOptions sera rappelé automatiquement avec les valeurs à jour
      }

      // Initialisation de l'ID de la table actuelle
      async function initCurrentTableId() {
        if (currentTableId) return currentTableId;
        const table = await grist.getTable();
        currentTableId = await table._platform.getTableId();
        return currentTableId;
      }

      // Récupère les options persistées
      grist.onOptions((opts) => {
        widgetOptions = opts || {};
      });

      // Fonction pour récupérer toutes les colonnes de la table actuelle
      async function getAllColumns() {
        const table = await grist.getTable();
        const tableId = await table._platform.getTableId();
        const tables = await grist.docApi.fetchTable("_grist_Tables");
        const columns = await grist.docApi.fetchTable("_grist_Tables_column");
        const fields = Object.keys(columns);

        const tableColumns = [];
        if (!tableId) {
          console.log("Aucun id de table trouvé");
          return tableColumns;
        }
        const tableRef = tables.id[tables.tableId.indexOf(tableId)];
        for (const index in columns.parentId) {
          if (columns.parentId[index] === tableRef) {
            // On reconstruit une "ligne" objet depuis la table en colonnes
            tableColumns.push(
              Object.fromEntries(fields.map((f) => [f, columns[f][index]]))
            );
          }
        }
        return tableColumns;
      }

      // Fonction pour reconstruire la liste des en-têtes visibles en fonction des colonnes masquées

      function buildVisibleHeaders(colMeta, allHeaders) {
        const colId = colMeta.colId || colMeta.id;
        const hidden = new Set(getHiddenFor(colId).map(norm));
        return allHeaders.filter((h) => !hidden.has(norm(h.value)));
      }
      /* ---------------------------------------------
         Helpers pour reconnaître Choice/ChoiceList
         et extraire l'ordre des 'choices' depuis widgetOptions
         --------------------------------------------- */
      function isChoiceLike(colMeta) {
        const wo = safeParse(colMeta?.widgetOptions);
        // Certaines versions stockent le widget +/ou les choices
        return (
          wo?.widget === "Choice" ||
          wo?.widget === "ChoiceList" ||
          !!wo?.choices ||
          !!wo?.choicesById
        );
      }
      function getChoicesFromMeta(colMeta) {
        const wo = safeParse(colMeta?.widgetOptions);
        if (!wo) return [];

        let result = [];

        // 1) Si wo.choices est un tableau
        if (wo && Array.isArray(wo.choices)) {
          for (const c of wo.choices) {
            let label;
            if (typeof c === "string") {
              label = c;
            } else if (c && (c.label != null || c.value != null)) {
              label = c.label != null ? c.label : c.value;
            } else {
              label = "";
            }
            if (label) result.push(label);
          }
          return result;
        }

        // 2) Sinon, si wo.choicesById est un objet
        if (wo && typeof wo.choicesById === "object") {
          for (const key of Object.keys(wo.choicesById)) {
            const c = wo.choicesById[key];
            const label = (c && (c.label ?? c.value)) || "";
            if (label) result.push(label);
          }
          return result;
        }

        // 3) Sinon, rien
        return result;
      }

      // Initialisation du menu déroulant avec les colonnes de type "Choice"

      (async () => {
        try {
          const cols = await getAllColumns();
          allColsMeta = cols;

          for (const col of cols) {
            if (isChoiceLike(col)) {
              const option = document.createElement("option");
              option.value = col.colId || col.id || "";
              option.textContent = col.label || col.colId || "(?)";
              select.appendChild(option);
              choices.push(col);
            }
          }
        } catch (e) {
          console.error(e);
        }
      })();

      // Marque une carte comme "draggable" et envoie les infos utiles lors du drag
      function makeCardDraggable(cardEl, rowId, fromHeaderValue, sourceColId) {
        cardEl.draggable = true; // indispensable pour activer le drag natif
        cardEl.addEventListener("dragstart", (e) => {
          // On stocke dans le dataTransfer les infos utiles pour l'update au drop
          e.dataTransfer.setData("rowId", String(rowId));
          e.dataTransfer.setData("fromHeader", fromHeaderValue); // valeur d'origine (ex: "À faire")
          e.dataTransfer.setData("sourceColId", sourceColId); // nom du champ (ex: "Statut")
          e.dataTransfer.effectAllowed = "move";
        });
      }

      // Fonction pour rendre les en-têtes basés sur les valeurs uniques de la colonne sélectionnée
      function renderHeader(source, records) {
        const order = getChoicesFromMeta(source);
        wrapper.innerHTML = "";
        const headers = order.map((value, index) => ({ index, value }));
        headers.unshift({ index: 0, value: empty });
        return headers;
      }

      // Fonction pour afficher le panneau de gestion de la visibilité des colonnes
      function renderVisibilityUI(colMeta) {
        const colId = colMeta.colId || colMeta.id;
        const all = [empty, ...getChoicesFromMeta(colMeta)]; // toutes les colonnes possibles
        const hidden = new Set(getHiddenFor(colId).map(norm));

        visPanel.innerHTML = "<div class='font-medium mb-2'>Colonnes :</div>";
        const list = document.createElement("div");
        list.className = "grid grid-cols-2 gap-1";
        visPanel.appendChild(list);

        for (const label of all) {
          const row = document.createElement("label");
          row.className = "flex items-center gap-2";
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = !hidden.has(norm(label)); // coché = visible
          cb.addEventListener("change", async () => {
            const cur = new Set(getHiddenFor(colId).map(norm));
            const key = norm(label);
            if (cb.checked) cur.delete(key);
            else cur.add(key);
            await setHiddenFor(colId, Array.from(cur));
            rerenderKanban(colMeta, lastRecords, colId); // réaffiche/récache immédiatement
            renderVisibilityUI(colMeta); // refresh le panneau
          });
          const span = document.createElement("span");
          span.textContent = label;
          row.appendChild(cb);
          row.appendChild(span);
          list.appendChild(row);
        }
      }

      visBtn.addEventListener("click", () => {
        visPanel.classList.toggle("hidden");
      });

      // Panneau de gestion des champs affichés dans les cartes
      function renderFieldsUI(colMeta) {
        // colMeta = meta de la SOURCE (Choice)
        const tableCols = allColsMeta;
        const sourceColId = colMeta.colId || colMeta.id;

        // récupère l’ID de table courant que tu as déjà en global (currentTableId)
        const tableId = currentTableId;
        if (!tableId) return;

        // liste des champs affichables dans les cards
        const fieldMetas = tableCols.filter((c) => {
          const cid = c.colId || c.id || "";
          if (!cid) return false;
          if (cid === sourceColId) return false; // on n’affiche pas la colonne Choice dans la carte
          return true;
        });

        // set des champs masqués (normalisés)
        const hidden = new Set(getHiddenFields(tableId, sourceColId).map(norm));

        fieldsPanel.innerHTML = "<div class='font-medium mb-2'>Champs :</div>";
        const list = document.createElement("div");
        list.className = "grid grid-cols-2 gap-1";
        fieldsPanel.appendChild(list);

        for (const fm of fieldMetas) {
          const cid = fm.colId || fm.id;
          const label = fm.label || cid;
          const row = document.createElement("label");
          row.className = "flex items-center gap-2";

          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.checked = !hidden.has(norm(cid)); // coché = visible

          cb.addEventListener("change", async () => {
            const cur = new Set(
              getHiddenFields(tableId, sourceColId).map(norm)
            );
            const key = norm(cid);
            if (cb.checked) cur.delete(key);
            else cur.add(key);
            await setHiddenFields(tableId, sourceColId, Array.from(cur));

            // re-render immédiat du Kanban
            const colId = sourceColId;
            const selectedColumn = catchColumn(choices, colId);
            if (selectedColumn) {
              rerenderKanban(selectedColumn, lastRecords, colId);
            }

            // refresh du panneau
            renderFieldsUI(colMeta);
          });

          const span = document.createElement("span");
          span.textContent = label;

          row.appendChild(cb);
          row.appendChild(span);
          list.appendChild(row);
        }
      }

      fieldsBtn.addEventListener("click", () => {
        fieldsPanel.classList.toggle("hidden");
      });

      // Fonction pour créer les éléments d'en-tête dans le DOM
      function createKanban(leadHeader, wrapper, records, source) {
        wrapper.innerHTML = "";

        const tableId = currentTableId;

        const hiddenFields = getHiddenFields(tableId, sourceColId);
        const hiddenFieldSet = new Set(hiddenFields.map(norm));
        const isDefault = hiddenFields.length === 0;

        for (const item of leadHeader) {
          const column = document.createElement("div");
          column.classList.add(
            "column",
            "p-3",
            "w-full",
            "h-full",
            "flex",
            "flex-col",
            "gap-4",
            "items-center"
          );
          wrapper.appendChild(column);

          const head = document.createElement("h2");
          head.textContent = item.value;
          head.classList.add("title", "bg-primary");
          column.prepend(head);

          // const colId = source;
          // const label = item.value;

          const hiddenSet = new Set(getHiddenFor(source).map(norm));
          const labelKey = norm(item.value);

          if (hiddenSet.has(labelKey)) {
            column.style.display = "none";
          }

          enableColumnDrop(column, item.value, source);

          for (const record of records) {
            const cellValue = record[source];
            const headerValue = item.value;

            let isMatch = false;

            if (headerValue === empty) {
              isMatch = isEmptyValue(cellValue);
            } else if (Array.isArray(cellValue)) {
              // ChoiceList : on vérifie si au moins une valeur de la liste correspond
              isMatch = cellValue.some(
                (v) => strNoAccent(v) === strNoAccent(headerValue)
              );
            } else {
              // Choice (scalaire)
              isMatch = strNoAccent(cellValue) === strNoAccent(headerValue);
            }

            if (!isMatch) continue;

            const card = document.createElement("div");
            card.classList.add(
              "card",
              "max-w-sm",
              "rounded-lg",
              "shadow-lg",
              "p-2",
              "h-auto",
              "pointer"
            );

            let keys = Object.keys(record).filter(
              (k) => k !== "id" && k !== source && !hiddenFieldSet.has(norm(k))
            );

            if (isDefault) {
              keys = keys.slice(0, 5);
            }

            for (const infos of keys) {
              const row = document.createElement("div");
              row.classList.add("flex", "gap-2", "items-center");
              const titleItem = document.createElement("h3");
              titleItem.innerHTML = `${infos}&nbsp;:`;
              const contentItem = document.createElement("p");
              contentItem.textContent = record[infos];
              row.appendChild(titleItem);
              row.appendChild(contentItem);
              card.appendChild(row);
            }
            column.appendChild(card);
            card.dataset.rowId = record.id;

            card.addEventListener("click", () => {
              if (record.id !== undefined) {
                grist.setCursorPos({ rowId: record.id }); // Position l'éditeur de Grist sur le bon record
              }
            });

            makeCardDraggable(card, record.id, item.value, source);
          }
        }
      }
      function rerenderKanban(selectedColumn, records, colId) {
        // 1) Construire TOUS les headers
        const allHeaders = renderHeader(selectedColumn, records); // ex. renvoie [{index, value}, …]

        // 2) Filtrer selon l’option "hidden" persistée
        const visibleHeaders = buildVisibleHeaders(selectedColumn, allHeaders);

        // 3) Dessiner uniquement les colonnes visibles
        createKanban(visibleHeaders, wrapper, records, colId);
      }

      function catchColumn(choices, selectedSource) {
        for (const col of choices) {
          if ((col.colId || col.id) === selectedSource) {
            return col; // on renvoie l'objet méta complet (accès à widgetOptions)
          }
        }
        return null;
      }

      // Met à jour la cellule (Choice ou ChoiceList) après un drop
      async function updateCardAfterDrop(
        rowId,
        sourceColId,
        fromHeaderValue,
        toHeaderValue,
        currentCellValue
      ) {
        await initCurrentTableId();
        // Normalise pour comparer sans accents
        const eq = (a, b) => strNoAccent(a) === strNoAccent(b);

        let newValue;
        if (toHeaderValue === empty) {
          newValue = Array.isArray(currentCellValue) ? [] : null;
        } else if (Array.isArray(currentCellValue)) {
          // CHOICELIST : on retire l'ancienne valeur (si présente) et on ajoute la nouvelle
          const withoutOld = currentCellValue.filter(
            (v) => !eq(v, fromHeaderValue)
          );
          // Évite doublon
          if (!withoutOld.some((v) => eq(v, toHeaderValue))) {
            withoutOld.push(toHeaderValue);
          }
          newValue = withoutOld;
        } else {
          // CHOICE (scalaire) : on remplace simplement par la nouvelle valeur
          newValue = toHeaderValue;
        }

        // Update côté Grist
        const action = [
          "UpdateRecord",
          currentTableId,
          rowId,
          { [sourceColId]: newValue },
        ];
        await grist.docApi.applyUserActions([action]);
      }

      // Active le drop sur une colonne Kanban donnée
      function enableColumnDrop(columnEl, headerValue, sourceColId) {
        // Autorise le dépôt
        columnEl.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          columnEl.classList.add("ring-2");
        });

        columnEl.addEventListener("dragleave", () => {
          columnEl.classList.remove("ring-2");
        });

        // Récupère les infos envoyées par la carte au dragstart et update
        columnEl.addEventListener("drop", async (e) => {
          e.preventDefault();
          columnEl.classList.remove("ring-2");
          const rowId = Number(e.dataTransfer.getData("rowId"));
          const fromHeader = e.dataTransfer.getData("fromHeader"); // d'où venait la carte
          const sourceCol = e.dataTransfer.getData("sourceColId"); // sécurité (doit = sourceColId)

          if (!rowId || !sourceCol) return;
          if (sourceCol !== sourceColId) return;

          // On a besoin de la valeur actuelle pour savoir si c'est ChoiceList
          const record = lastRecords.find((r) => r.id === rowId);
          if (!record) return;
          const currentCellValue = record[sourceColId];

          // headerValue = valeur de la colonne où on droppe
          await updateCardAfterDrop(
            rowId,
            sourceColId,
            fromHeader,
            headerValue,
            currentCellValue
          );
        });
      }

      // Écouteur d'événements pour le changement de sélection dans le menu déroulant
      select.addEventListener("change", async () => {
        const selectedSource = select.value;
        await setStoredSource(selectedSource);

        const selectedColumn = catchColumn(choices, selectedSource);
        if (!selectedColumn) return;
        renderVisibilityUI(selectedColumn);
        renderFieldsUI(selectedColumn);
        rerenderKanban(selectedColumn, lastRecords, selectedSource);
      });

      // Écouteurs d'événements Grist
      grist.onRecords(async (records) => {
        lastRecords = records || [];

        await initCurrentTableId();
        await initChoicesOnce();

        if (select.value === "none") {
          const stored = getStoredSource();
          if (stored) {
            const has = Array.from(select.options).some(
              (o) => o.value === stored
            );
            if (has) select.value = stored;
          }
        }
        const selectedSource = select.value;
        const selectedColumn = catchColumn(choices, selectedSource);
        if (!selectedColumn) return;
        renderVisibilityUI(selectedColumn);
        renderFieldsUI(selectedColumn);
        rerenderKanban(selectedColumn, lastRecords, selectedSource);
      });

      grist.onRecord((record) => {});
    </script>
  </body>
</html>
